qx.Class.define('{{baseNamespace}}.core.BaseService', {
  extend: qx.core.Object,
  type: 'abstract',

  /*
  *****************************************************************************
     CONSTRUCTOR
  *****************************************************************************
  */
  construct: function (url, metadata) {
    this.base(arguments){{lineEnd}}
    this.setUrl(url){{lineEnd}}

    if (metadata) {
      this.setMetadata(metadata){{lineEnd}}
    }
  },

  /*
  *****************************************************************************
     PROPERTIES
  *****************************************************************************
  */
  properties: {
    url: {
      check: 'String',
      init: 'null'
    },

    metadata: {
      check: 'Object',
      nullable: true,
      apply: '_applyMetadata'
    }
  },

  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */
  members: {
    __metadata: null,

    _applyMetadata: function (value) {
      if (value) {
        this.__metadata = new grpc.Metadata(value){{lineEnd}}
      } else {
        this.__metadata = null{{lineEnd}}
      }
    },

    _call: function (payload, serviceDefinition) {
      var args = qx.lang.Array.fromArguments(arguments, 2){{lineEnd}}
      var config = {
        request: payload,
        host: this.getUrl(),
        metadata: this.__metadata
        // debug: qx.core.Environment.get('qx.debug')
      }{{lineEnd}}
      var context = this{{lineEnd}}
      if (typeof args[args.length - 1] === 'object') {
        context = args.pop(){{lineEnd}}
      }
      return new qx.Promise(function (resolve, reject) {
        if (serviceDefinition.responseStream === true) {
          // streaming response
          
          var callback{{lineEnd}}
          if (typeof args[args.length - 1] === 'function') {
            callback = args.pop(){{lineEnd}}
          } else {
            throw Error('no callback defined'){{lineEnd}}
          }
          if (config.request === callback) {
            throw Error('no payload defined'){{lineEnd}}
          }
          grpc.invoke(serviceDefinition, Object.assign(config, {
            onMessage: callback.bind(context),
            onEnd: function (code, message, trailers) {
              if (code !== grpc.Code.OK) {
                reject(new Error(message)){{lineEnd}}
              }
              else {
                resolve(message){{lineEnd}}
              }
            },
            debug: {{debugInvoke}}
          })){{lineEnd}}
        }
        else {
          grpc.unary(serviceDefinition, Object.assign(config, {
            onEnd: function (res) {
              if (res.status !== grpc.Code.OK) {
                reject(new Error('RPC ' + serviceDefinition.methodName + ' returned an error: ' + res.statusMessage)){{lineEnd}}
              }
              else {
                resolve(res.message){{lineEnd}}
              }
            },
            debug: {{debugUnary}}
          })){{lineEnd}}
        }
      }, context){{lineEnd}}
    }
  }
}){{lineEnd}}